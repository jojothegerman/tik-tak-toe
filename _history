{"entries":[{"timestamp":1747838882841,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"0\" y=\"0\""],[0,"></b"]],"start1":67,"start2":67,"length1":20,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"205\" y=\"0\""],[0,"></b"]],"start1":107,"start2":107,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"v2\": \"*\",\n        \"warte bis...\": \"github:calliope-edu/warte-bis#705b034fbec4a032ae43a6284b152073836abbd1\""],[0,"\n   "]],"start1":89,"start2":89,"length1":125,"length2":8},{"diffs":[[0,".md\""],[-1,",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":173,"start2":173,"length1":64,"length2":44}]},{"type":"added","filename":"main.py","value":"# Tic-Tac-Toe (3-Gewinnt) für MakeCode Python auf Penelope Mini V2\n\nfrom microbit import pin0, pin1, pin2, pin3, pin4, running_time, sleep\nimport basic\n\n# Spielfeld 3×3: None=leer, True=Spieler 1 (LED an), False=Spieler 2 (LED aus)\nfield = [[None for _ in range(3)] for _ in range(3)]\n\n# Cursor-Position im 3×3-Feld\ncursor_x = 0\ncursor_y = 0\n\n# Aktueller Spieler: True=Spieler 1, False=Spieler 2\nplayer = True\n\n# Mappt 3×3 → 5×5 LED-Koordinate (zentriert)\ndef map_x(x):\n    return x + 1\n\ndef map_y(y):\n    return y + 1\n\n# Zeichnet Spielfeld und (optional) blinkenden Cursor\ndef draw(show_cursor):\n    basic.clear_screen()\n    # Alle gesetzten Steine zeichnen\n    for y in range(3):\n        for x in range(3):\n            v = field[y][x]\n            if v is not None:\n                brightness = 9 if v else 0\n                basic.set_pixel(map_x(x), map_y(y), brightness)\n    # Cursor auf leerem Feld blinken lassen\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        basic.set_pixel(map_x(cursor_x), map_y(cursor_y), 9)\n\n# Prüft Sieg für aktuellen Spieler\ndef check_win():\n    p = player\n    # Reihen & Spalten\n    for i in range(3):\n        if field[i][0] == field[i][1] == field[i][2] == p:\n            return True\n        if field[0][i] == field[1][i] == field[2][i] == p:\n            return True\n    # Diagonalen\n    if field[0][0] == field[1][1] == field[2][2] == p:\n        return True\n    if field[0][2] == field[1][1] == field[2][0] == p:\n        return True\n    return False\n\n# Prüft Unentschieden (kein freies Feld)\ndef check_draw():\n    for row in field:\n        if None in row:\n            return False\n    return True\n\n# Cursor innerhalb der Grenzen bewegen\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\n# Blinken bei Sieg oder Unentschieden\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        basic.clear_screen()\n        sleep(interval)\n        draw(False)\n        sleep(interval)\n\n# Hauptspiel-Schleife\ndef game_loop():\n    global player\n    last_blink = running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        # Cursor-Blink ca. alle 400 ms\n        if running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = running_time()\n\n        # Bewegungs-Tasten P0–P3 (active-low)\n        if pin0.read_digital() == 0:\n            move_cursor(0, -1)\n            draw(blink_on)\n            sleep(200)\n        if pin1.read_digital() == 0:\n            move_cursor(0, 1)\n            draw(blink_on)\n            sleep(200)\n        if pin2.read_digital() == 0:\n            move_cursor(-1, 0)\n            draw(blink_on)\n            sleep(200)\n        if pin3.read_digital() == 0:\n            move_cursor(1, 0)\n            draw(blink_on)\n            sleep(200)\n\n        # Aktionstaste P4: Feld setzen\n        if pin4.read_digital() == 0:\n            if field[cursor_y][cursor_x] is None:\n                # Zug ausführen\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                sleep(200)\n                # Gewinn prüfen\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                # Unentschieden prüfen\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                # Spieler wechseln\n                player = not player\n            sleep(200)\n\n# Spiel starten\ngame_loop()\n\n"}]},{"timestamp":1747839464204,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[1,"# Tic-Tac-Toe (3-Gewinnt) für MakeCode Python auf Penelope Mini V2\n\nfrom microbit import pin0, pin1, pin2, pin3, pin4, running_time, sleep\nimport basic\n\n# Spielfeld 3×3: None=leer, True=Spieler 1 (LED an), False=Spieler 2 (LED aus)\nfield = [[None for _ in range(3)] for _ in range(3)]\n\n# Cursor-Position im 3×3-Feld\ncursor_x = 0\ncursor_y = 0\n\n# Aktueller Spieler: True=Spieler 1, False=Spieler 2\nplayer = True\n\n# Mappt 3×3 → 5×5 LED-Koordinate (zentriert)\ndef map_x(x):\n    return x + 1\n\ndef map_y(y):\n    return y + 1\n\n# Zeichnet Spielfeld und (optional) blinkenden Cursor\ndef draw(show_cursor):\n    basic.clear_screen()\n    # Alle gesetzten Steine zeichnen\n    for y in range(3):\n        for x in range(3):\n            v = field[y][x]\n            if v is not None:\n                brightness = 9 if v else 0\n                basic.set_pixel(map_x(x), map_y(y), brightness)\n    # Cursor auf leerem Feld blinken lassen\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        basic.set_pixel(map_x(cursor_x), map_y(cursor_y), 9)\n\n# Prüft Sieg für aktuellen Spieler\ndef check_win():\n    p = player\n    # Reihen & Spalten\n    for i in range(3):\n        if field[i][0] == field[i][1] == field[i][2] == p:\n            return True\n        if field[0][i] == field[1][i] == field[2][i] == p:\n            return True\n    # Diagonalen\n    if field[0][0] == field[1][1] == field[2][2] == p:\n        return True\n    if field[0][2] == field[1][1] == field[2][0] == p:\n        return True\n    return False\n\n# Prüft Unentschieden (kein freies Feld)\ndef check_draw():\n    for row in field:\n        if None in row:\n            return False\n    return True\n\n# Cursor innerhalb der Grenzen bewegen\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\n# Blinken bei Sieg oder Unentschieden\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        basic.clear_screen()\n        sleep(interval)\n        draw(False)\n        sleep(interval)\n\n# Hauptspiel-Schleife\ndef game_loop():\n    global player\n    last_blink = running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        # Cursor-Blink ca. alle 400 ms\n        if running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = running_time()\n\n        # Bewegungs-Tasten P0–P3 (active-low)\n        if pin0.read_digital() == 0:\n            move_cursor(0, -1)\n            draw(blink_on)\n            sleep(200)\n        if pin1.read_digital() == 0:\n            move_cursor(0, 1)\n            draw(blink_on)\n            sleep(200)\n        if pin2.read_digital() == 0:\n            move_cursor(-1, 0)\n            draw(blink_on)\n            sleep(200)\n        if pin3.read_digital() == 0:\n            move_cursor(1, 0)\n            draw(blink_on)\n            sleep(200)\n\n        # Aktionstaste P4: Feld setzen\n        if pin4.read_digital() == 0:\n            if field[cursor_y][cursor_x] is None:\n                # Zug ausführen\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                sleep(200)\n                # Gewinn prüfen\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                # Unentschieden prüfen\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                # Spieler wechseln\n                player = not player\n            sleep(200)\n\n# Spiel starten\ngame_loop()\n\n"]],"start1":0,"start2":0,"length1":0,"length2":3550}]}]},{"timestamp":1747840062767,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[-1,"# Tic-Tac-Toe (3-Gewinnt) für MakeCode Python auf Penelope Mini V2\n\nimport basic\nimport input\nimport pins\nfrom pin import DigitalPin\n\n# Spielfeld 3×3: None=leer, True=Spieler 1 (LED an), False=Spieler 2 (LED aus)\nfield = [[None for _ in range(3)] for _ in range(3)]\n\n# Cursor-Position im 3×3-Feld\ncursor_x = 0\ncursor_y = 0\n\n# Aktueller Spieler: True=Spieler 1, False=Spieler 2\nplayer = True\n\n# 3×3 → zentrierte 5×5-LED-Koordinate\ndef map_x(x): return x + 1\ndef map_y(y): return y + 1\n\n# Zeichne Spielfeld und (optional) blinkenden Cursor\ndef draw(show_cursor):\n    basic.clear_screen()\n    # Steine\n    for y in range(3):\n        for x in range(3):\n            v = field[y][x]\n            if v is True:\n                basic.set_led(map_x(x), map_y(y), 9)\n            elif v is False:\n                basic.set_led(map_x(x), map_y(y), 0)\n    # Cursor auf freiem Feld\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        basic.set_led(map_x(cursor_x), map_y(cursor_y), 9)\n\n# Siegprüfung\ndef check_win():\n    p = player\n    for i in range(3):\n        if field[i][0]==field[i][1]==field[i][2]==p: return True\n        if field[0][i]==field[1][i]==field[2][i]==p: return True\n    if field[0][0]==field[1][1]==field[2][2]==p: return True\n    if field[0][2]==field[1][1]==field[2][0]==p: return True\n    return False\n\n# Unentschieden prüfen\ndef check_draw():\n    for row in field:\n        if None in row: return False\n    return True\n\n# Cursorbegrenzung\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\n# Blink-Animation\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        basic.clear_screen()\n        basic.pause(interval)\n        draw(False)\n        basic.pause(interval)\n\n# Haupt-Loop\ndef game_loop():\n    global player\n    last_blink = input.running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        # Cursor-Blink ~400 ms\n        if input.running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = input.running_time()\n\n        # Bewegungs-Tasten P0–P3 (active-low)\n        if pins.digital_read_pin(DigitalPin.P0) == 0:\n            move_cursor(0, -1); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P1) == 0:\n            move_cursor(0,  1); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P2) == 0:\n            move_cursor(-1, 0); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P3) == 0:\n            move_cursor(1,  0); draw(blink_on); basic.pause(200)\n\n        # Aktionstaste P4: Zug setzen\n        if pins.digital_read_pin(DigitalPin.P4) == 0:\n            if field[cursor_y][cursor_x] is None:\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                basic.pause(200)\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                player = not player\n            basic.pause(200)\n\n# Spiel starten\ngame_loop()\nled.toggle(0, 0) zum schaltein eines bestimmten pixel und led.point(0, 0) um zuschauen ob eine led an oder aus ist,\nled.plot(0, 0) zum anschalten der angegeben kordinaten,\nled.unplot(0, 0)\n\n"]],"start1":0,"start2":0,"length1":3400,"length2":0}]}]},{"timestamp":1747840657713,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"i V2"],[-1,"\n# Verwendung von input.pin_is_pressed(TouchPin.Px) und input.running_time()"],[0,"\n\nim"]],"start1":62,"start2":62,"length1":84,"length2":8},{"diffs":[[0,"ort "],[-1,"led"],[1,"pins"],[0,"\nfrom "],[-1,"microbit"],[1,"pin"],[0," import "],[-1,"Touch"],[1,"Digital"],[0,"Pin\n"]],"start1":97,"start2":97,"length1":38,"length2":36},{"diffs":[[0,"rte 5×5-"],[1,"LED-"],[0,"Koordina"]],"start1":407,"start2":407,"length1":16,"length2":20},{"diffs":[[0," 1\n\n"],[-1,"# Komplettes Display löschen\ndef clear_all():\n    basic.clear_screen()\n\n"],[0,"# Ze"]],"start1":481,"start2":481,"length1":80,"length2":8},{"diffs":[[0,"eld "],[-1,"+ "],[1,"und ("],[0,"optional"],[1,")"],[0," bli"]],"start1":501,"start2":501,"length1":18,"length2":22},{"diffs":[[0,"    "],[-1,"clear_all()\n    # gesetzte Felder"],[1,"basic.clear_screen()\n    # Steine"],[0,"\n   "]],"start1":561,"start2":561,"length1":41,"length2":41},{"diffs":[[0,"            "],[-1,"led.plot"],[1,"basic.set_led"],[0,"(map_x(x), m"]],"start1":707,"start2":707,"length1":32,"length2":37},{"diffs":[[0,"x), map_y(y)"],[1,", 9"],[0,")\n          "]],"start1":739,"start2":739,"length1":24,"length2":27},{"diffs":[[0,"    "],[-1,"led.unplot"],[1,"basic.set_led"],[0,"(map"]],"start1":797,"start2":797,"length1":18,"length2":21},{"diffs":[[0,"map_y(y)"],[1,", 0"],[0,")\n    # "]],"start1":825,"start2":825,"length1":16,"length2":19},{"diffs":[[0,"auf "],[-1,"leer"],[1,"frei"],[0,"em Feld"],[-1," blinken lassen"],[0,"\n   "]],"start1":851,"start2":851,"length1":34,"length2":19},{"diffs":[[0,"    "],[-1,"led.plot"],[1,"basic.set_led"],[0,"(map"]],"start1":929,"start2":929,"length1":16,"length2":21},{"diffs":[[0,"r_y)"],[1,", 9"],[0,")\n\n# "],[-1,"Prüft Sieg für aktuellen Spieler"],[1,"Siegprüfung"],[0,"\ndef"]],"start1":975,"start2":975,"length1":45,"length2":27},{"diffs":[[0,"e\n\n#"],[-1," Prüft"],[0," Une"]],"start1":1321,"start2":1321,"length1":14,"length2":8},{"diffs":[[0,"den "],[-1,"(kein freies Feld)"],[1,"prüfen"],[0,"\ndef"]],"start1":1336,"start2":1336,"length1":26,"length2":14},{"diffs":[[0," in row:"],[-1,"\n           "],[0," return "]],"start1":1402,"start2":1402,"length1":28,"length2":16},{"diffs":[[0,"rsor"],[-1," bewegen, Grenzen [0..2]"],[1,"begrenzung"],[0,"\ndef"]],"start1":1445,"start2":1445,"length1":32,"length2":18},{"diffs":[[0,"tion"],[-1," bei Sieg/Unentschieden"],[0,"\ndef"]],"start1":1619,"start2":1619,"length1":31,"length2":8},{"diffs":[[0,"    "],[-1,"clear_all"],[1,"basic.clear_screen"],[0,"()\n "]],"start1":1695,"start2":1695,"length1":17,"length2":26},{"diffs":[[0,"aupt"],[-1,"spiel-Schleife"],[1,"-Loop"],[0,"\ndef"]],"start1":1804,"start2":1804,"length1":22,"length2":13},{"diffs":[[0,"rsor"],[-1," b"],[1,"-B"],[0,"link"],[-1,"t"],[0," ~40"]],"start1":1955,"start2":1955,"length1":15,"length2":14},{"diffs":[[0,"  # "],[-1,"Cursor-"],[0,"Bewegung"],[-1," mit TouchPin.P0–P3"],[1,"s-Tasten P0–P3 (active-low)"],[0,"\n   "]],"start1":2142,"start2":2142,"length1":42,"length2":43},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.pin_is_pressed(Touch"],[1,"s.digital_read_pin(Digital"],[0,"Pin.P0)"],[1," == 0"],[0,":\n  "]],"start1":2189,"start2":2189,"length1":41,"length2":49},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.pin_is_pressed(Touch"],[1,"s.digital_read_pin(Digital"],[0,"Pin.P1)"],[1," == 0"],[0,":\n  "]],"start1":2308,"start2":2308,"length1":41,"length2":49},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.pin_is_pressed(Touch"],[1,"s.digital_read_pin(Digital"],[0,"Pin.P2)"],[1," == 0"],[0,":\n  "]],"start1":2427,"start2":2427,"length1":41,"length2":49},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.pin_is_pressed(Touch"],[1,"s.digital_read_pin(Digital"],[0,"Pin.P3)"],[1," == 0"],[0,":\n  "]],"start1":2546,"start2":2546,"length1":41,"length2":49},{"diffs":[[0,"nstaste "],[-1,"TouchPin."],[0,"P4: Zug "]],"start1":2674,"start2":2674,"length1":25,"length2":16},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.pin_is_pressed(Touch"],[1,"s.digital_read_pin(Digital"],[0,"Pin.P4)"],[1," == 0"],[0,":\n  "]],"start1":2704,"start2":2704,"length1":41,"length2":49},{"diffs":[[0,"op()"],[-1,"P0\nif input"],[1,"\nled.toggle(0, 0) zum schaltein eines bestimmten pixel und led"],[0,".p"],[1,"o"],[0,"in"],[-1,"_is_pressed(pins.digital_read_pin(DigitalPin.P0))"],[1,"t(0, 0) um zuschauen ob eine led an oder aus ist,\nled.plot(0, 0) zum anschalten der angegeben kordinaten,\nled.unplot(0, 0)\n\n"]],"start1":3205,"start2":3205,"length1":68,"length2":195}]}]},{"timestamp":1747841202860,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[1,"# Tic-Tac-Toe (3-Gewinnt) für MakeCode Python auf Penelope Mini V2\n# Verwendung von input.pin_is_pressed(TouchPin.Px) und input.running_time()\n\n"],[0,"import basic"]],"start1":0,"start2":0,"length1":12,"length2":156},{"diffs":[[0,"led\n"],[1,"from microbit "],[0,"import "],[-1,"p"],[1,"TouchP"],[0,"in"],[-1,"s"],[0,"\n\n# "]],"start1":177,"start2":177,"length1":19,"length2":37},{"diffs":[[0,"pieler 1"],[1," (LED an)"],[0,", False="]],"start1":246,"start2":246,"length1":16,"length2":25},{"diffs":[[0,"pieler 2"],[1," (LED aus)"],[0,"\nfield ="]],"start1":272,"start2":272,"length1":16,"length2":26},{"diffs":[[0,"Position"],[1," im 3×3-Feld"],[0,"\ncursor_"]],"start1":354,"start2":354,"length1":16,"length2":28},{"diffs":[[0,"eler"],[-1,"\nplayer = True\n\n# Umrechnung auf mittleres 3x3-Feld der 5x5-LED-Matrix"],[1,": True=Spieler 1, False=Spieler 2\nplayer = True\n\n# 3×3 → zentrierte 5×5-Koordinate"],[0,"\ndef"]],"start1":417,"start2":417,"length1":78,"length2":90},{"diffs":[[0,"\n\n# "],[-1,"Bildschirm"],[1,"Komplettes Display"],[0," lös"]],"start1":557,"start2":557,"length1":18,"length2":26},{"diffs":[[0,"_screen()\n\n#"],[1," Zeichne"],[0," Spielfeld u"]],"start1":620,"start2":620,"length1":24,"length2":32},{"diffs":[[0,"eld "],[-1,"und Cursor zeichnen"],[1,"+ optional blinkenden Cursor"],[0,"\ndef"]],"start1":647,"start2":647,"length1":27,"length2":36},{"diffs":[[0,"clear_all()\n"],[1,"    # gesetzte Felder\n"],[0,"    for y in"]],"start1":707,"start2":707,"length1":24,"length2":46},{"diffs":[[0,", map_y(y))\n"],[1,"    # Cursor auf leerem Feld blinken lassen\n"],[0,"    if show_"]],"start1":954,"start2":954,"length1":24,"length2":68},{"diffs":[[0,"\n\n# "],[-1,"Sieg prüfen"],[1,"Prüft Sieg für aktuellen Spieler"],[0,"\ndef"]],"start1":1118,"start2":1118,"length1":19,"length2":40},{"diffs":[[0," field[i][0]"],[-1," "],[0,"=="],[-1," "],[0,"field[i][1] "]],"start1":1220,"start2":1220,"length1":28,"length2":26},{"diffs":[[0,"=field[i][1]"],[-1," "],[0,"=="],[-1," "],[0,"field[i][2] "]],"start1":1233,"start2":1233,"length1":28,"length2":26},{"diffs":[[0,"=field[i][2]"],[-1," "],[0,"=="],[-1," "],[0,"p: return Tr"]],"start1":1246,"start2":1246,"length1":28,"length2":26},{"diffs":[[0," field[0][i]"],[-1," "],[0,"=="],[-1," "],[0,"field[1][i] "]],"start1":1285,"start2":1285,"length1":28,"length2":26},{"diffs":[[0,"ld[1][i]"],[-1," "],[0,"=="],[-1," "],[0,"field[2]"]],"start1":1302,"start2":1302,"length1":20,"length2":18},{"diffs":[[0,"ld[2][i]"],[-1," "],[0,"=="],[-1," "],[0,"p: retur"]],"start1":1315,"start2":1315,"length1":20,"length2":18},{"diffs":[[0,"ld[0][0]"],[-1," "],[0,"=="],[-1," "],[0,"field[1]"]],"start1":1350,"start2":1350,"length1":20,"length2":18},{"diffs":[[0,"[0]==field[1][1]"],[-1," "],[0,"=="],[-1," "],[0,"field[2][2] == p"]],"start1":1355,"start2":1355,"length1":36,"length2":34},{"diffs":[[0,"ld[2][2]"],[-1," "],[0,"=="],[-1," "],[0,"p: retur"]],"start1":1376,"start2":1376,"length1":20,"length2":18},{"diffs":[[0,"ld[0][2]"],[-1," "],[0,"=="],[-1," "],[0,"field[1]"]],"start1":1411,"start2":1411,"length1":20,"length2":18},{"diffs":[[0,"ld[1][1]"],[-1," "],[0,"=="],[-1," "],[0,"field[2]"]],"start1":1424,"start2":1424,"length1":20,"length2":18},{"diffs":[[0,"ld[2][0]"],[-1," "],[0,"=="],[-1," "],[0,"p: retur"]],"start1":1437,"start2":1437,"length1":20,"length2":18},{"diffs":[[0,"False\n\n#"],[1," Prüft"],[0," Unentsc"]],"start1":1473,"start2":1473,"length1":16,"length2":22},{"diffs":[[0,"den "],[-1,"prüfen"],[1,"(kein freies Feld)"],[0,"\ndef"]],"start1":1498,"start2":1498,"length1":14,"length2":26},{"diffs":[[0," bewegen"],[1,", Grenzen [0..2]"],[0,"\ndef mov"]],"start1":1635,"start2":1635,"length1":16,"length2":32},{"diffs":[[0,"link"],[-1,"a"],[1,"-A"],[0,"nimation"],[1," bei Sieg/Unentschieden"],[0,"\ndef"]],"start1":1809,"start2":1809,"length1":17,"length2":41},{"diffs":[[0,"uptspiel"],[1,"-Schleife"],[0,"\ndef gam"]],"start1":2019,"start2":2019,"length1":16,"length2":25},{"diffs":[[0,"or blink"],[-1,"en"],[1,"t ~400 ms"],[0,"\n       "]],"start1":2180,"start2":2180,"length1":18,"length2":25},{"diffs":[[0,"  # "],[1,"Cursor-"],[0,"Bewegung"],[1," mit TouchPin.P0–P3"],[0,"\n   "]],"start1":2366,"start2":2366,"length1":16,"length2":42},{"diffs":[[0," if "],[-1,"p"],[0,"in"],[-1,"s.digital_read_pin(p"],[1,"put.pin_is_pressed(TouchP"],[0,"in"],[-1,"s"],[0,".P0)"],[-1," == 0"],[0,":\n  "]],"start1":2412,"start2":2412,"length1":43,"length2":41},{"diffs":[[0," if "],[-1,"p"],[0,"in"],[-1,"s.digital_read_pin(p"],[1,"put.pin_is_pressed(TouchP"],[0,"in"],[-1,"s"],[0,".P1)"],[-1," == 0"],[0,":\n  "]],"start1":2523,"start2":2523,"length1":43,"length2":41},{"diffs":[[0,"ursor(0,"],[1," "],[0," 1); dra"]],"start1":2580,"start2":2580,"length1":16,"length2":17},{"diffs":[[0," if "],[-1,"p"],[0,"in"],[-1,"s.digital_read_pin(p"],[1,"put.pin_is_pressed(TouchP"],[0,"in"],[-1,"s"],[0,".P2)"],[-1," == 0"],[0,":\n  "]],"start1":2634,"start2":2634,"length1":43,"length2":41},{"diffs":[[0," if "],[-1,"p"],[0,"in"],[-1,"s.digital_read_pin(p"],[1,"put.pin_is_pressed(TouchP"],[0,"in"],[-1,"s"],[0,".P3)"],[-1," == 0"],[0,":\n  "]],"start1":2745,"start2":2745,"length1":43,"length2":41},{"diffs":[[0,"ursor(1,"],[1," "],[0," 0); dra"]],"start1":2802,"start2":2802,"length1":16,"length2":17},{"diffs":[[0," # A"],[-1,"uswahlfeld"],[1,"ktionstaste TouchPin.P4: Zug"],[0," set"]],"start1":2857,"start2":2857,"length1":18,"length2":36},{"diffs":[[0," if "],[-1,"p"],[0,"in"],[-1,"s.digital_read_pin(p"],[1,"put.pin_is_pressed(TouchP"],[0,"in"],[-1,"s"],[0,".P4)"],[-1," == 0"],[0,":\n  "]],"start1":2904,"start2":2904,"length1":43,"length2":41},{"diffs":[[0,"e_loop()"],[-1,"\n"],[1,"P0\nif input.pin_is_pressed(pins.digital_read_pin(DigitalPin.P0))"]],"start1":3393,"start2":3393,"length1":9,"length2":72}]}]},{"timestamp":1747841750845,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"//  Spielfeld (3x3): None=leer, True=Spieler 1, False=Spieler 2\nlet field =  {TODO: ListComp} \nlet cursor_x = 0\nlet cursor_y = 0\nlet player = true\n//  True = Spieler 1, False = Spieler 2\nfunction map_x(x: number): number {\n    return x + 1\n}\n\nfunction map_y(y: number): number {\n    return y + 1\n}\n\nfunction clear_all() {\n    basic.clearScreen()\n}\n\nfunction draw(show_cursor: boolean) {\n    let val: any;\n    clear_all()\n    for (let y = 0; y < 3; y++) {\n        for (let x = 0; x < 3; x++) {\n            val = field[y][x]\n            if (val === true) {\n                led.plot(map_x(x), map_y(y))\n            } else if (val === false) {\n                led.unplot(map_x(x), map_y(y))\n            }\n            \n        }\n    }\n    if (show_cursor && field[cursor_y][cursor_x] === null) {\n        led.plot(map_x(cursor_x), map_y(cursor_y))\n    }\n    \n}\n\nfunction check_win(): boolean {\n    let p = player\n    for (let i = 0; i < 3; i++) {\n        if (field[i][0] == field[i][1] && field[i][1] == field[i][2] && field[i][2] == p) {\n            return true\n        }\n        \n        if (field[0][i] == field[1][i] && field[1][i] == field[2][i] && field[2][i] == p) {\n            return true\n        }\n        \n    }\n    if (field[0][0] == field[1][1] && field[1][1] == field[2][2] && field[2][2] == p) {\n        return true\n    }\n    \n    if (field[0][2] == field[1][1] && field[1][1] == field[2][0] && field[2][0] == p) {\n        return true\n    }\n    \n    return false\n}\n\nfunction check_draw(): boolean {\n    for (let row of field) {\n        if (row.indexOf(null) >= 0) {\n            return false\n        }\n        \n    }\n    return true\n}\n\nfunction move_cursor(dx: number, dy: number) {\n    \n    cursor_x = Math.max(0, Math.min(2, cursor_x + dx))\n    cursor_y = Math.max(0, Math.min(2, cursor_y + dy))\n}\n\nfunction blink_pattern(times: number, interval: number = 200) {\n    for (let _ = 0; _ < times; _++) {\n        clear_all()\n        basic.pause(interval)\n        draw(false)\n        basic.pause(interval)\n    }\n}\n\nfunction reset_game() {\n    \n    field =  {TODO: ListComp} \n    player = true\n    cursor_x = 0\n    cursor_y = 0\n    draw(true)\n}\n\nfunction game_loop() {\n    \n    let last_blink = input.runningTime()\n    let blink_on = true\n    draw(blink_on)\n    while (true) {\n        //  Cursor blinkt alle 400ms\n        if (input.runningTime() - last_blink > 400) {\n            blink_on = !blink_on\n            draw(blink_on)\n            last_blink = input.runningTime()\n        }\n        \n        //  Cursor-Steuerung über Pins\n        if (pins.digitalReadPin(DigitalPin.P0) == 0) {\n            move_cursor(0, -1)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        if (pins.digitalReadPin(DigitalPin.P1) == 0) {\n            move_cursor(0, 1)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        if (pins.digitalReadPin(DigitalPin.P2) == 0) {\n            move_cursor(-1, 0)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        if (pins.digitalReadPin(DigitalPin.P3) == 0) {\n            move_cursor(1, 0)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        //  Feld setzen mit Button A\n        if (input.buttonIsPressed(Button.A)) {\n            if (field[cursor_y][cursor_x] === null) {\n                field[cursor_y][cursor_x] = player\n                draw(false)\n                basic.pause(200)\n                if (check_win()) {\n                    blink_pattern(6, 150)\n                    return\n                }\n                \n                if (check_draw()) {\n                    blink_pattern(4, 100)\n                    return\n                }\n                \n                player = !player\n            }\n            \n            basic.pause(200)\n        }\n        \n        //  Spiel zurücksetzen mit Button B\n        if (input.buttonIsPressed(Button.A)) {\n            reset_game()\n            basic.pause(500)\n        }\n        \n    }\n}\n\n//  Starte das Spiel\nreset_game()\ngame_loop()"],[0,"\n"]],"start1":0,"start2":0,"length1":4033,"length2":1}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"pins"],[-1,"\nfrom microbit import *"],[0,"\n\n# "]],"start1":44,"start2":44,"length1":31,"length2":8},{"diffs":[[0,"eld "],[-1,"(3x3)"],[1,"3×3"],[0,": No"]],"start1":58,"start2":58,"length1":13,"length2":11},{"diffs":[[0,"ge(3)]\n\n"],[1,"# Cursor-Position\n"],[0,"cursor_x"]],"start1":156,"start2":156,"length1":16,"length2":34},{"diffs":[[0,"= 0\n"],[-1,"player = True  # True = Spieler 1, False = Spieler 2\n"],[1,"\n# Aktueller Spieler\nplayer = True\n\n# Umrechnung auf mittleres 3x3-Feld der 5x5-LED-Matrix"],[0,"\ndef"]],"start1":204,"start2":204,"length1":61,"length2":98},{"diffs":[[0," y + 1\n\n"],[1,"# Bildschirm löschen\n"],[0,"def clea"]],"start1":346,"start2":346,"length1":16,"length2":37},{"diffs":[[0,"reen()\n\n"],[1,"# Spielfeld und Cursor zeichnen\n"],[0,"def draw"]],"start1":410,"start2":410,"length1":16,"length2":48},{"diffs":[[0,"       v"],[-1,"al"],[0," = field"]],"start1":544,"start2":544,"length1":18,"length2":16},{"diffs":[[0,"        if v"],[-1,"al"],[0," is True:\n  "]],"start1":571,"start2":571,"length1":26,"length2":24},{"diffs":[[0,"  elif v"],[-1,"al"],[0," is Fals"]],"start1":648,"start2":648,"length1":18,"length2":16},{"diffs":[[0,"cursor_y))\n\n"],[1,"# Sieg prüfen\n"],[0,"def check_wi"]],"start1":812,"start2":812,"length1":24,"length2":38},{"diffs":[[0," False\n\n"],[1,"# Unentschieden prüfen\n"],[0,"def chec"]],"start1":1179,"start2":1179,"length1":16,"length2":39},{"diffs":[[0,"n True\n\n"],[1,"# Cursor bewegen\n"],[0,"def move"]],"start1":1308,"start2":1308,"length1":16,"length2":33},{"diffs":[[0,"+ dy))\n\n"],[1,"# Blinkanimation\n"],[0,"def blin"]],"start1":1471,"start2":1471,"length1":16,"length2":33},{"diffs":[[0,"l)\n\n"],[-1,"def reset_game():\n    global field, player, cursor_x, cursor_y\n    field = [[None for _ in range(3)] for _ in range(3)]\n    player = True\n    cursor_x = 0\n    cursor_y = 0\n    draw(True)\n"],[1,"# Hauptspiel"],[0,"\ndef"]],"start1":1660,"start2":1660,"length1":195,"length2":20},{"diffs":[[0,"link"],[-1,"t alle 400ms"],[1,"en"],[0,"\n   "]],"start1":1824,"start2":1824,"length1":20,"length2":10},{"diffs":[[0,"  # "],[-1,"Cursor-Steuerung über Pins"],[1,"Bewegung"],[0,"\n   "]],"start1":1999,"start2":1999,"length1":34,"length2":16},{"diffs":[[0,"ead_pin("],[-1,"DigitalP"],[1,"p"],[0,"in"],[1,"s"],[0,".P0) == "]],"start1":2037,"start2":2037,"length1":26,"length2":20},{"diffs":[[0,"ead_pin("],[-1,"DigitalP"],[1,"p"],[0,"in"],[1,"s"],[0,".P1) == "]],"start1":2150,"start2":2150,"length1":26,"length2":20},{"diffs":[[0,"ead_pin("],[-1,"DigitalP"],[1,"p"],[0,"in"],[1,"s"],[0,".P2) == "]],"start1":2262,"start2":2262,"length1":26,"length2":20},{"diffs":[[0,"pin("],[-1,"DigitalP"],[1,"p"],[0,"in"],[1,"s"],[0,".P3)"]],"start1":2379,"start2":2379,"length1":18,"length2":12},{"diffs":[[0,"      # "],[-1,"F"],[1,"Auswahlf"],[0,"eld setz"]],"start1":2465,"start2":2465,"length1":17,"length2":24},{"diffs":[[0,"tzen"],[-1," mit Button A"],[0,"\n   "]],"start1":2487,"start2":2487,"length1":21,"length2":8},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.button_is_pressed(Button.A)"],[1,"s.digital_read_pin(pins.P4) == 0"],[0,":\n  "]],"start1":2499,"start2":2499,"length1":41,"length2":43},{"diffs":[[0,"0)\n\n"],[-1,"        # Spiel zurücksetzen mit Button B\n        if button_b.is_pressed():\n            reset_game()\n            basic.pause(500)\n\n# Starte das Spiel\nreset_game()"],[1,"# Spiel starten"],[0,"\ngam"]],"start1":2967,"start2":2967,"length1":170,"length2":23}]}]},{"timestamp":1747842238588,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"//  Spielfeld (3x3): None=leer, True=Spieler 1, False=Spieler 2\nlet field =  {TODO: ListComp} \nlet cursor_x = 0\nlet cursor_y = 0\nlet player = true\n//  True = Spieler 1, False = Spieler 2\nfunction map_x(x: number): number {\n    return x + 1\n}\n\nfunction map_y(y: number): number {\n    return y + 1\n}\n\nfunction clear_all() {\n    basic.clearScreen()\n}\n\nfunction draw(show_cursor: boolean) {\n    let val: any;\n    clear_all()\n    for (let y = 0; y < 3; y++) {\n        for (let x = 0; x < 3; x++) {\n            val = field[y][x]\n            if (val === true) {\n                led.plot(map_x(x), map_y(y))\n            } else if (val === false) {\n                led.unplot(map_x(x), map_y(y))\n            }\n            \n        }\n    }\n    if (show_cursor && field[cursor_y][cursor_x] === null) {\n        led.plot(map_x(cursor_x), map_y(cursor_y))\n    }\n    \n}\n\nfunction check_win(): boolean {\n    let p = player\n    for (let i = 0; i < 3; i++) {\n        if (field[i][0] == field[i][1] && field[i][1] == field[i][2] && field[i][2] == p) {\n            return true\n        }\n        \n        if (field[0][i] == field[1][i] && field[1][i] == field[2][i] && field[2][i] == p) {\n            return true\n        }\n        \n    }\n    if (field[0][0] == field[1][1] && field[1][1] == field[2][2] && field[2][2] == p) {\n        return true\n    }\n    \n    if (field[0][2] == field[1][1] && field[1][1] == field[2][0] && field[2][0] == p) {\n        return true\n    }\n    \n    return false\n}\n\nfunction check_draw(): boolean {\n    for (let row of field) {\n        if (row.indexOf(null) >= 0) {\n            return false\n        }\n        \n    }\n    return true\n}\n\nfunction move_cursor(dx: number, dy: number) {\n    \n    cursor_x = Math.max(0, Math.min(2, cursor_x + dx))\n    cursor_y = Math.max(0, Math.min(2, cursor_y + dy))\n}\n\nfunction blink_pattern(times: number, interval: number = 200) {\n    for (let _ = 0; _ < times; _++) {\n        clear_all()\n        basic.pause(interval)\n        draw(false)\n        basic.pause(interval)\n    }\n}\n\nfunction reset_game() {\n    \n    field =  {TODO: ListComp} \n    player = true\n    cursor_x = 0\n    cursor_y = 0\n    draw(true)\n}\n\nfunction game_loop() {\n    \n    let last_blink = input.runningTime()\n    let blink_on = true\n    draw(blink_on)\n    while (true) {\n        //  Cursor blinkt alle 400ms\n        if (input.runningTime() - last_blink > 400) {\n            blink_on = !blink_on\n            draw(blink_on)\n            last_blink = input.runningTime()\n        }\n        \n        //  Cursor-Steuerung über Pins\n        if (pins.digitalReadPin(DigitalPin.P0) == 0) {\n            move_cursor(0, -1)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        if (pins.digitalReadPin(DigitalPin.P1) == 0) {\n            move_cursor(0, 1)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        if (pins.digitalReadPin(DigitalPin.P2) == 0) {\n            move_cursor(-1, 0)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        if (pins.digitalReadPin(DigitalPin.P3) == 0) {\n            move_cursor(1, 0)\n            draw(blink_on)\n            basic.pause(200)\n        }\n        \n        //  Feld setzen mit Button A\n        if (input.buttonIsPressed(Button.A)) {\n            if (field[cursor_y][cursor_x] === null) {\n                field[cursor_y][cursor_x] = player\n                draw(false)\n                basic.pause(200)\n                if (check_win()) {\n                    blink_pattern(6, 150)\n                    return\n                }\n                \n                if (check_draw()) {\n                    blink_pattern(4, 100)\n                    return\n                }\n                \n                player = !player\n            }\n            \n            basic.pause(200)\n        }\n        \n        //  Spiel zurücksetzen mit Button B\n        if (input.buttonIsPressed(Button.A)) {\n            reset_game()\n            basic.pause(500)\n        }\n        \n    }\n}\n\n//  Starte das Spiel\nreset_game()\ngame_loop()"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":4033}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"ort pins"],[1,"\nfrom microbit import *"],[0,"\n\n# Spie"]],"start1":40,"start2":40,"length1":16,"length2":39},{"diffs":[[0,"while True:\n"],[1,"        # Cursor blinkt alle 400ms\n"],[0,"        if i"]],"start1":1821,"start2":1821,"length1":24,"length2":59},{"diffs":[[0," > 400:\n"],[-1,""],[0,"        "]],"start1":1912,"start2":1912,"length1":16,"length2":16},{"diffs":[[0,"# Cursor"],[-1,"s"],[1,"-S"],[0,"teuerung"]],"start1":2038,"start2":2038,"length1":17,"length2":18},{"diffs":[[0,"ung "],[-1,"mit"],[1,"über"],[0," Pins"],[-1," P0–P3"],[0,"\n   "]],"start1":2053,"start2":2053,"length1":22,"length2":17},{"diffs":[[0," if "],[-1," input.pin_is_pressed(Touch"],[1,"pins.digital_read_pin(Digital"],[0,"Pin.P0)"],[1," "],[0,"== 0"]],"start1":2074,"start2":2074,"length1":42,"length2":45},{"diffs":[[0," if "],[-1," input.pin_is_pressed(Touch"],[1,"pins.digital_read_pin(Digital"],[0,"Pin.P1)"],[1," "],[0,"== 0"]],"start1":2193,"start2":2193,"length1":42,"length2":45},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.pin_is_pressed(Touch"],[1,"s.digital_read_pin(Digital"],[0,"Pin."]],"start1":2311,"start2":2311,"length1":34,"length2":37},{"diffs":[[0,"ead_pin("],[-1,"p"],[1,"DigitalP"],[0,"in"],[-1,"s"],[0,".P3) == "]],"start1":2448,"start2":2448,"length1":20,"length2":26},{"diffs":[[0,"  # "],[-1,"Button A: Zug setzen"],[1,"Feld setzen mit Button A"],[0,"\n   "]],"start1":2548,"start2":2548,"length1":28,"length2":32},{"diffs":[[0,"   #"],[-1," Button B:"],[0," Spi"]],"start1":3059,"start2":3059,"length1":18,"length2":8},{"diffs":[[0,"cksetzen"],[1," mit Button B"],[0,"\n       "]],"start1":3074,"start2":3074,"length1":16,"length2":29},{"diffs":[[0,"\n        if "],[-1,"input."],[0,"button_"],[1,"b."],[0,"is_pressed(B"]],"start1":3095,"start2":3095,"length1":37,"length2":33},{"diffs":[[0,"sed("],[-1,"Button.B"],[0,"):\n "]],"start1":3123,"start2":3123,"length1":16,"length2":8},{"diffs":[[0,"_game()\n"],[1,""],[0,"game_loo"]],"start1":3209,"start2":3209,"length1":16,"length2":16},{"diffs":[[0,"_loop()\n"],[-1,"\n"]],"start1":3221,"start2":3221,"length1":9,"length2":8}]}]},{"timestamp":1747842838137,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"led\n"],[-1,"from microbit "],[0,"import "],[-1,"TouchP"],[1,"p"],[0,"in"],[1,"s"],[0,"\n\n# "]],"start1":33,"start2":33,"length1":37,"length2":19},{"diffs":[[0,"ung mit "],[-1,"Touch"],[0,"Pin"],[-1,"."],[1,"s "],[0,"P0–P3\n  "]],"start1":1994,"start2":1994,"length1":25,"length2":21},{"diffs":[[0,"0–P3\n        if "],[1," "],[0,"input.pin_is_pre"]],"start1":2008,"start2":2008,"length1":32,"length2":33},{"diffs":[[0,"hPin.P0)"],[1,"== 0"],[0,":\n      "]],"start1":2050,"start2":2050,"length1":16,"length2":20},{"diffs":[[0,"200)\n        if "],[1," "],[0,"input.pin_is_pre"]],"start1":2124,"start2":2124,"length1":32,"length2":33},{"diffs":[[0,"hPin.P1)"],[1,"== 0"],[0,":\n      "]],"start1":2166,"start2":2166,"length1":16,"length2":20},{"diffs":[[0,"hPin.P2)"],[1," == 0"],[0,":\n      "]],"start1":2280,"start2":2280,"length1":16,"length2":21},{"diffs":[[0," if "],[1,"p"],[0,"in"],[-1,"put.pin_is_pressed(TouchP"],[1,"s.digital_read_pin(p"],[0,"in"],[1,"s"],[0,".P3)"],[1," == 0"],[0,":\n  "]],"start1":2367,"start2":2367,"length1":41,"length2":43},{"diffs":[[0,"on A"],[-1," = Spielz"],[1,": Z"],[0,"ug s"]],"start1":2487,"start2":2487,"length1":17,"length2":11},{"diffs":[[0,"utton.A)"],[-1," "],[0,":\n      "]],"start1":2540,"start2":2540,"length1":17,"length2":16},{"diffs":[[0,"Button B"],[-1," ="],[1,":"],[0," Spiel z"]],"start1":2991,"start2":2991,"length1":18,"length2":17},{"diffs":[[0,"\n# S"],[-1,"piel starten"],[1,"tarte das Spiel"],[0,"\nres"]],"start1":3120,"start2":3120,"length1":20,"length2":23}]}]},{"timestamp":1747843511149,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[1,"import basic\nimport input\nimport led\nfrom microbit import TouchPin\n\n# Spielfeld (3x3): None=leer, True=Spieler 1, False=Spieler 2\nfield = [[None for _ in range(3)] for _ in range(3)]\n\ncursor_x = 0\ncursor_y = 0\nplayer = True  # True = Spieler 1, False = Spieler 2\n\ndef map_x(x): return x + 1\ndef map_y(y): return y + 1\n\ndef clear_all():\n    basic.clear_screen()\n\ndef draw(show_cursor):\n    clear_all()\n    for y in range(3):\n        for x in range(3):\n            val = field[y][x]\n            if val is True:\n                led.plot(map_x(x), map_y(y))\n            elif val is False:\n                led.unplot(map_x(x), map_y(y))\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        led.plot(map_x(cursor_x), map_y(cursor_y))\n\ndef check_win():\n    p = player\n    for i in range(3):\n        if field[i][0] == field[i][1] == field[i][2] == p: return True\n        if field[0][i] == field[1][i] == field[2][i] == p: return True\n    if field[0][0] == field[1][1] == field[2][2] == p: return True\n    if field[0][2] == field[1][1] == field[2][0] == p: return True\n    return False\n\ndef check_draw():\n    for row in field:\n        if None in row:\n            return False\n    return True\n\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        clear_all()\n        basic.pause(interval)\n        draw(False)\n        basic.pause(interval)\n\ndef reset_game():\n    global field, player, cursor_x, cursor_y\n    field = [[None for _ in range(3)] for _ in range(3)]\n    player = True\n    cursor_x = 0\n    cursor_y = 0\n    draw(True)\n\ndef game_loop():\n    global player\n    last_blink = input.running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        if input.running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = input.running_time()\n\n        # Cursorsteuerung mit TouchPin.P0–P3\n        if input.pin_is_pressed(TouchPin.P0):\n            move_cursor(0, -1); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(TouchPin.P1):\n            move_cursor(0, 1); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(TouchPin.P2):\n            move_cursor(-1, 0); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(TouchPin.P3):\n            move_cursor(1, 0); draw(blink_on); basic.pause(200)\n\n        # Button A = Spielzug setzen\n        if input.button_is_pressed(Button.A) :\n            if field[cursor_y][cursor_x] is None:\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                basic.pause(200)\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                player = not player\n            basic.pause(200)\n\n        # Button B = Spiel zurücksetzen\n        if input.button_is_pressed(Button.B):\n            reset_game()\n            basic.pause(500)\n\n# Spiel starten\nreset_game()\ngame_loop()\n"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":3176}]}]},{"timestamp":1747843659534,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[-1,"import basic\nimport input\nimport led\nfrom microbit import Button\n\n# Spielfeld (3x3): None = leer, True = Spieler 1, False = Spieler 2\nfield = [[None for _ in range(3)] for _ in range(3)]\n\ncursor_x = 0\ncursor_y = 0\nplayer = True  # True = Spieler 1, False = Spieler 2\n\n# 3×3-Feld auf 5×5 Display abbilden\ndef map_x(x): return x + 1\ndef map_y(y): return y + 1\n\ndef clear_all():\n    basic.clear_screen()\n\ndef draw(show_cursor):\n    clear_all()\n    for y in range(3):\n        for x in range(3):\n            val = field[y][x]\n            if val is True:\n                led.plot(map_x(x), map_y(y))\n            elif val is False:\n                led.unplot(map_x(x), map_y(y))\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        led.plot(map_x(cursor_x), map_y(cursor_y))\n\ndef check_win():\n    p = player\n    for i in range(3):\n        if field[i][0] == field[i][1] == field[i][2] == p: return True\n        if field[0][i] == field[1][i] == field[2][i] == p: return True\n    if field[0][0] == field[1][1] == field[2][2] == p: return True\n    if field[0][2] == field[1][1] == field[2][0] == p: return True\n    return False\n\ndef check_draw():\n    for row in field:\n        if None in row:\n            return False\n    return True\n\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        clear_all()\n        basic.pause(interval)\n        draw(False)\n        basic.pause(interval)\n\ndef reset_game():\n    global field, player, cursor_x, cursor_y\n    field = [[None for _ in range(3)] for _ in range(3)]\n    player = True\n    cursor_x = 0\n    cursor_y = 0\n    draw(True)\n\ndef game_loop():\n    global player\n    last_blink = input.running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        # Cursor blinkt alle ~400 ms\n        if input.running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = input.running_time()\n\n        # Cursorsteuerung mit Pins P0–P3\n        if input.pin_is_pressed(input.pin0):\n            move_cursor(0, -1); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(input.pin1):\n            move_cursor(0, 1); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(input.pin2):\n            move_cursor(-1, 0); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(input.pin3):\n            move_cursor(1, 0); draw(blink_on); basic.pause(200)\n\n        # Button A = Spielzug setzen\n        if input.button_is_pressed(Button.A) :\n            if field[cursor_y][cursor_x] is None:\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                basic.pause(200)\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                player = not player\n            basic.pause(200)\n\n        # Button B = Spiel zurücksetzen\n        if input.button_is_pressed(Button.B):\n            reset_game()\n            basic.pause(500)\n\n# Spiel starten\nreset_game()\ngame_loop()\n"],[0,"\n"]],"start1":0,"start2":0,"length1":3245,"length2":1}]}]},{"timestamp":1747843872085,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":111}]}]},{"timestamp":1747844611629,"editorVersion":"7.0.3","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":317,"start2":317,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// Hier kann man Tests durchführen; diese Datei wird nicht kompiliert, wenn dieses Paket als Erweiterung verwendet wird.\n"}]}],"snapshots":[{"timestamp":1747838882840,"editorVersion":"7.0.3","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"tik-tak-toe\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1747840683840,"editorVersion":"7.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"","README.md":"","main.py":"# Tic-Tac-Toe (3-Gewinnt) für MakeCode Python auf Penelope Mini V2\n\nimport basic\nimport input\nimport pins\nfrom pin import DigitalPin\n\n# Spielfeld 3×3: None=leer, True=Spieler 1 (LED an), False=Spieler 2 (LED aus)\nfield = [[None for _ in range(3)] for _ in range(3)]\n\n# Cursor-Position im 3×3-Feld\ncursor_x = 0\ncursor_y = 0\n\n# Aktueller Spieler: True=Spieler 1, False=Spieler 2\nplayer = True\n\n# 3×3 → zentrierte 5×5-LED-Koordinate\ndef map_x(x): return x + 1\ndef map_y(y): return y + 1\n\n# Zeichne Spielfeld und (optional) blinkenden Cursor\ndef draw(show_cursor):\n    basic.clear_screen()\n    # Steine\n    for y in range(3):\n        for x in range(3):\n            v = field[y][x]\n            if v is True:\n                basic.set_led(map_x(x), map_y(y), 9)\n            elif v is False:\n                basic.set_led(map_x(x), map_y(y), 0)\n    # Cursor auf freiem Feld\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        basic.set_led(map_x(cursor_x), map_y(cursor_y), 9)\n\n# Siegprüfung\ndef check_win():\n    p = player\n    for i in range(3):\n        if field[i][0]==field[i][1]==field[i][2]==p: return True\n        if field[0][i]==field[1][i]==field[2][i]==p: return True\n    if field[0][0]==field[1][1]==field[2][2]==p: return True\n    if field[0][2]==field[1][1]==field[2][0]==p: return True\n    return False\n\n# Unentschieden prüfen\ndef check_draw():\n    for row in field:\n        if None in row: return False\n    return True\n\n# Cursorbegrenzung\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\n# Blink-Animation\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        basic.clear_screen()\n        basic.pause(interval)\n        draw(False)\n        basic.pause(interval)\n\n# Haupt-Loop\ndef game_loop():\n    global player\n    last_blink = input.running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        # Cursor-Blink ~400 ms\n        if input.running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = input.running_time()\n\n        # Bewegungs-Tasten P0–P3 (active-low)\n        if pins.digital_read_pin(DigitalPin.P0) == 0:\n            move_cursor(0, -1); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P1) == 0:\n            move_cursor(0,  1); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P2) == 0:\n            move_cursor(-1, 0); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P3) == 0:\n            move_cursor(1,  0); draw(blink_on); basic.pause(200)\n\n        # Aktionstaste P4: Zug setzen\n        if pins.digital_read_pin(DigitalPin.P4) == 0:\n            if field[cursor_y][cursor_x] is None:\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                basic.pause(200)\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                player = not player\n            basic.pause(200)\n\n# Spiel starten\ngame_loop()\nled.toggle(0, 0) zum schaltein eines bestimmten pixel und led.point(0, 0) um zuschauen ob eine led an oder aus ist,\nled.plot(0, 0) zum anschalten der angegeben kordinaten,\nled.unplot(0, 0)zum ausschalten der kordinate\n\n","pxt.json":"{\n    \"name\": \"tik-tak-toe\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"v2\": \"*\",\n        \"warte bis...\": \"github:calliope-edu/warte-bis#705b034fbec4a032ae43a6284b152073836abbd1\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1747842485594,"editorVersion":"7.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"","README.md":"","main.py":"import basic\nimport input\nimport led\nimport pins\nfrom microbit import DigitalPin, Button\n\n# Spielfeld (3x3): None=leer, True=Spieler 1, False=Spieler 2\nfield = [[None for _ in range(3)] for _ in range(3)]\n\ncursor_x = 0\ncursor_y = 0\nplayer = True  # True = Spieler 1, False = Spieler 2\n\ndef map_x(x): return x + 1\ndef map_y(y): return y + 1\n\ndef clear_all():\n    basic.clear_screen()\n\ndef draw(show_cursor):\n    clear_all()\n    for y in range(3):\n        for x in range(3):\n            val = field[y][x]\n            if val is True:\n                led.plot(map_x(x), map_y(y))\n            elif val is False:\n                led.unplot(map_x(x), map_y(y))\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        led.plot(map_x(cursor_x), map_y(cursor_y))\n\ndef check_win():\n    p = player\n    for i in range(3):\n        if field[i][0] == field[i][1] == field[i][2] == p: return True\n        if field[0][i] == field[1][i] == field[2][i] == p: return True\n    if field[0][0] == field[1][1] == field[2][2] == p: return True\n    if field[0][2] == field[1][1] == field[2][0] == p: return True\n    return False\n\ndef check_draw():\n    for row in field:\n        if None in row:\n            return False\n    return True\n\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        clear_all()\n        basic.pause(interval)\n        draw(False)\n        basic.pause(interval)\n\ndef reset_game():\n    global field, player, cursor_x, cursor_y\n    field = [[None for _ in range(3)] for _ in range(3)]\n    player = True\n    cursor_x = 0\n    cursor_y = 0\n    draw(True)\n\ndef game_loop():\n    global player\n    last_blink = input.running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        if input.running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = input.running_time()\n\n        # Cursorsteuerung mit P0–P3\n        if pins.digital_read_pin(DigitalPin.P0) == 0:\n            move_cursor(0, -1); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P1) == 0:\n            move_cursor(0, 1); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P2) == 0:\n            move_cursor(-1, 0); draw(blink_on); basic.pause(200)\n        if pins.digital_read_pin(DigitalPin.P3) == 0:\n            move_cursor(1, 0); draw(blink_on); basic.pause(200)\n\n        # Zug setzen mit Button A\n        if input.button_is_pressed(Button.A):\n            if field[cursor_y][cursor_x] is None:\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                basic.pause(200)\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                player = not player\n            basic.pause(200)\n\n        # Spiel zurücksetzen mit Button B\n        if input.button_is_pressed(ton.ButB):\n            reset_game()\n            basic.pause(500)\n\n# Starte das Spiel\nreset_game()\ngame_loop()\n\n","pxt.json":"{\n    \"name\": \"tik-tak-toe\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"v2\": \"*\",\n        \"warte bis...\": \"github:calliope-edu/warte-bis#705b034fbec4a032ae43a6284b152073836abbd1\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1747844611629,"editorVersion":"7.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"","README.md":"","main.py":"import basic\nimport input\nimport led\nfrom microbit import Button\n\n# Spielfeld (3x3): None = leer, True = Spieler 1, False = Spieler 2\nfield = [[None for _ in range(3)] for _ in range(3)]\n\ncursor_x = 0\ncursor_y = 0\nplayer = True  # True = Spieler 1, False = Spieler 2\n\n# 3×3-Feld auf 5×5 Display abbilden\ndef map_x(x): return x + 1\ndef map_y(y): return y + 1\n\ndef clear_all():\n    basic.clear_screen()\n\ndef draw(show_cursor):\n    clear_all()\n    for y in range(3):\n        for x in range(3):\n            val = field[y][x]\n            if val is True:\n                led.plot(map_x(x), map_y(y))\n            elif val is False:\n                led.unplot(map_x(x), map_y(y))\n    if show_cursor and field[cursor_y][cursor_x] is None:\n        led.plot(map_x(cursor_x), map_y(cursor_y))\n\ndef check_win():\n    p = player\n    for i in range(3):\n        if field[i][0] == field[i][1] == field[i][2] == p: return True\n        if field[0][i] == field[1][i] == field[2][i] == p: return True\n    if field[0][0] == field[1][1] == field[2][2] == p: return True\n    if field[0][2] == field[1][1] == field[2][0] == p: return True\n    return False\n\ndef check_draw():\n    for row in field:\n        if None in row:\n            return False\n    return True\n\ndef move_cursor(dx, dy):\n    global cursor_x, cursor_y\n    cursor_x = max(0, min(2, cursor_x + dx))\n    cursor_y = max(0, min(2, cursor_y + dy))\n\ndef blink_pattern(times, interval=200):\n    for _ in range(times):\n        clear_all()\n        basic.pause(interval)\n        draw(False)\n        basic.pause(interval)\n\ndef reset_game():\n    global field, player, cursor_x, cursor_y\n    field = [[None for _ in range(3)] for _ in range(3)]\n    player = True\n    cursor_x = 0\n    cursor_y = 0\n    draw(True)\n\ndef game_loop():\n    global player\n    last_blink = input.running_time()\n    blink_on = True\n    draw(blink_on)\n\n    while True:\n        # Cursor blinkt alle ~400 ms\n        if input.running_time() - last_blink > 400:\n            blink_on = not blink_on\n            draw(blink_on)\n            last_blink = input.running_time()\n\n        # Cursorsteuerung mit Pins P0–P3\n        if input.pin_is_pressed(input.pin0):\n            move_cursor(0, -1); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(input.pin1):\n            move_cursor(0, 1); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(input.pin2):\n            move_cursor(-1, 0); draw(blink_on); basic.pause(200)\n        if input.pin_is_pressed(input.pin3):\n            move_cursor(1, 0); draw(blink_on); basic.pause(200)\n\n        # Button A = Spielzug setzen\n        if input.button_is_pressed(Button.A) :\n            if field[cursor_y][cursor_x] is None:\n                field[cursor_y][cursor_x] = player\n                draw(False)\n                basic.pause(200)\n                if check_win():\n                    blink_pattern(6, 150)\n                    return\n                if check_draw():\n                    blink_pattern(4, 100)\n                    return\n                player = not player\n            basic.pause(200)\n\n        # Button B = Spiel zurücksetzen\n        if input.button_is_pressed(Button.B):\n            reset_game()\n            basic.pause(500)\n\n# Spiel starten\nreset_game()\ngame_loop()\n\n","pxt.json":"{\n    \"name\": \"tik-tak-toe\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"v2\": \"*\",\n        \"warte bis...\": \"github:calliope-edu/warte-bis#705b034fbec4a032ae43a6284b152073836abbd1\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}}],"shares":[],"lastSaveTime":1747844611638}